### 与缓存相关的http报文首部字段
有以下四个类型

#### 通用首部字段
1. Cache-Control: 控制缓存的行为
2. Pragma: http1.0的遗留物，值为'no-cache'时禁用缓存

#### 请求首部字段
1. If-Match: 比较ETag是否一致
2. If-None-Match: 比较ETag是否不一致
3. If-Modified-Since: 比较资源最后更新的时间是否一致
4. If-Unmodified-Since: 比较资源最后更新的时间是否不一致

#### 响应首部字段
1. ETag: 资源的匹配信息

#### 实体首部字段
1. Expires: http1.0的遗留物，实体主体过期的时间
2. Last-Modified: 资源的最后一次修改的时间

### http1.0时代的缓存
在http1.0的时候，使用`Pragma`和`Expires`做缓存，虽然现在已抛弃，当时为了做http协议的向下兼容，还是需要带上这2个字段

#### 1.Pragma
值为`no-cache`的时候，会告知客户端不要对该资源进行缓存，每次都向服务器发起一次请求，Pragma优先级高于Cache-Control

#### 2.Expires
Pragma禁用缓存，Expires用来开启缓存和定义缓存时间，值为一个GMT时间，来告诉浏览器资源缓存过期时间，如果没有过该时间则不发起请求，该时间为服务器上的时间。如果Pragma和Expires同时存在，则Pragma起作用

### Cache-Control
Expires是相对服务器的时间，无法和客户端时间统一，http1.1新增了Cache-Control来定义缓存过期时间，缓存优先级高低分别是Pragma > Cache-Control > Expires。Cache-Control允许自由组合可选值，这种组合的方式也会有些限制，比如`no-cache`就不能和`max-age`、`min-fresh`、`max-stale`一起搭配使用

#### Cache-Control作为请求首部的可选值为
1. no-cache: 告知(代理)服务器，不直接使用缓存，先向服务器发起请求看资源是否被更改，再决定是否使用缓存
2. no-store: 所有内容都不会保存或缓存到Internet临时文件中
3. max-age=30: 资源缓存时间为30秒
4. max-stale=30: 能容忍的最大过期时间，可以接受一个超过缓存时间的资源，如果写了30则为30秒内，没写则为任意时间
5. min-fresh=30: 设定能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。
6. no-transform: 客户端希望获取的实体没有被转换过
7. only-if-cached: 只要缓存的内容。only-if-cached请求指定指示了客户端指向获取一个缓存的响应。如果接收到这个指定，cache应该要么用缓存的内容给出响应，要么给出一个504(GateWay Timeout)响应码。如果一组cache被作为一个内部相连的系统，那么其中的某个成员可以向这个缓存组里请求响应

#### Cache-Control作为响应首部的可选值为
1. public: 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存
2. private: 表明响应只能被单个用户缓存，不能作为共享缓存(即代理服务器不能缓存它),可以缓存响应内容
3. no-cache: 不直接使用缓存，先向服务器发起请求看资源是否被更改，再决定是否使用缓存
4. no-store: 所有内容都不会保存或缓存到Internet临时文件中
5. no-transform: 告诉客户端缓存时不要对实体进行转换
6. only-if-cached: 只要缓存的内容。only-if-cached请求指定指示了客户端指向获取一个缓存的响应。如果接收到这个指定，cache应该要么用缓存的内容给出响应，要么给出一个504(GateWay Timeout)响应码。如果一组cache被作为一个内部相连的系统，那么其中的某个成员可以向这个缓存组里请求响应
7. must-revalidate: 资源一定是向原服务器发起验证请求的，失败会返回504(而不是代理服务器)
8. proxy-revalidate: 与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略
9. max-age=30: 告知客户端该资源在30秒内是新鲜的
10. s-maxage=30: 覆盖max-age或者Expires头，但是仅适用于共享缓存(比如各个代理)，并且私有缓存中它被忽略

### 缓存校验字段
上面的首部字段让客户端决定是否向服务器发起请求，如果缓存命中，在chrome中表现为200 from cache,如果缓存过期，需要验证缓存是否更新，提升缓存的复用率。
#### 1.Last-Modified
服务器将资源传递给客户端时，会将资源最后更改的时间以'Last-Modified: GMT'的形式加在实体首部上一起返回给客户端，客户端会给该资源标记上信息，下次再请求时，会把该信息附带在请求报文中给服务器做检查，如果传递的时间值雨服务器上该资源最终修改的时间一致，则说明资源未被修改，直接返回304，内容为空，如果时间不一致，则返回200，将新资源返回。Last-Modified存在一定问题，如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）
1. If-Modified-Since: Last-Modified-value，该请求首部告诉服务器如果客户端传来的最后修改时间与服务器上的一致，则直接回送304 和响应报头即可。当前各浏览器均是使用的该请求首部来向服务器传递保存的Last-Modified值
2. If-Unmodified-Since: Last-Modified-value，该值告诉服务器，若Last-Modified没有匹配上（资源在服务端的最后更新时间改变了)，则应当返回412(Precondition Failed) 状态码给客户端。
#### 2.Etag
为了解决last-modified可能存在的不准确的问题，http1.1新增Etag实体首部字段，服务器通过某个算法，计算出一个唯一的标识，把资源响应给客户端的时候，在实体首部上加上该字段。客户端会保留该字段，在下一次请求的时候一并带过去，服务器通过比对Etag的值来看资源是否被修改过了，一致则返回304，否则返回200。
1. If-None-Match: ETag-value,告诉服务器如果ETag没匹配上需要重发资源，否则返回304
2. If-Match: ETag-value,告诉服务器如果没有匹配到ETag或者收到了*而当前并没有该资源，则返回412(Precondition Failed)状态码给客户端

### 用户刷新行为
用户可以通过三种方式访问/刷新页面，请求的方式是不一样的
#### 1.在URI输入栏中输入然后回车
这种情况会带上之前的last-modified，如果有缓存会直接走缓存，200 from cache
#### 2.F5刷新
和在URI输入栏中输入然后回车不一样，F5会让浏览器无论如何都发一个HTTP Request，Chrome会强制加上`Cache-Control: max-age=0`，如果有协商缓存，会走协商缓存，返回304 Not Modified
#### 3.Ctl+F5
强制从server拿一份新的资源过来，去掉协商缓存相关的字段，还加上`Cache-Control: no-cache`和`Pragma: no-cache`，防止中间缓存

### 最佳实践
在项目上做缓存的时候，实际上还是会把上面说的大多数字段用上
#### 1.Expires/Cache-Control
Expires用时刻来标识失效时间，不免收到时间同步的影响，而Cache-Control使用时间间隔很好的解决了这个问题。 但是Cache-Control是HTTP1.1才有的，不适用于HTTP1.0，而Expires既适用于HTTP1.0，也适用于HTTP1.1，所以说在大多数情况下同时发送这两个头会是一个更好的选择，当客户端两种头都能解析的时候，会优先使用Cache-Control
#### 2.Last-Modified / ETag
二者都是通过某个标识值来请求资源，如果服务器端的资源没有变化，则自动返回HTTP 304（Not Changed）状态码，内容为空，这样就节省了传输数据量。而当资源发生变化后，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。其中Last-Modified使用文件最后修改作为文件标识值，它无法处理文件一秒内多次修改的情况，而且只要文件修改了哪怕文件实质内容没有修改，也会重新返回资源内容；ETag作为“被请求变量的实体值”，其完全可以解决Last-Modified头部的问题，但是其计算过程需要耗费服务器资源
#### 3.from-cache / 304
Expires和Cache-Control都有一个问题就是服务端作为的修改，如果还在缓存时效里，那么客户端是不会去请求服务端资源的（非刷新），这就存在一个资源版本不符的问题，而强制刷新一定会发起HTTP请求并返回资源内容，无论该内容在这段时间内是否修改过；而Last-Modified和Etag每次请求资源都会发起请求，哪怕是很久都不会有修改的资源，都至少有一次请求响应的消耗。
对于所有可缓存资源，指定一个Expires或Cache-Control max-age以及一个Last-Modified或ETag至关重要。同时使用前者和后者可以很好的相互适应。
前者不需要每次都发起一次请求来校验资源时效性，后者保证当资源未出现修改的时候不需要重新发送该资源。而在用户的不同刷新页面行为中，二者的结合也能很好的利用HTTP缓存控制特性，无论是在地址栏输入URI然后输入回车进行访问，还是点击刷新按钮，浏览器都能充分利用缓存内容，避免进行不必要的请求与数据传输
#### 4.避免304
给文件名后面加上文件的MD5值或者文件夹名字起一个特性值，然后给文件的Expires和Cache-Control时间设置很长，这样处理可以增加静态资源的缓存时间，避免了缓存过期向服务器端发起资源请求，服务器在返回304的情况